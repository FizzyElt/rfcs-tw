<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust RFC Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="2000-const-generics.html">2000-const-generics</a></li><li class="chapter-item expanded "><a href="2342-const-control-flow.html">2342-const-control-flow</a></li><li class="chapter-item expanded "><a href="2495-min-rust-version.html">2495-min-rust-version</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-rfcs---a-hrefhttpsrfcbotrsactive-rfc-lista"><a class="header" href="#rust-rfcs---a-hrefhttpsrfcbotrsactive-rfc-lista">Rust RFCs - <a href="https://rfcbot.rs/">Active RFC List</a></a></h1>
<p><strong>注意</strong>：這是官方 rust rfcs 的 fork。如果你有興趣協助翻譯的話，歡迎前往 <a href="CONTRIBUTING.html">CONTRIBUTING.md</a> 瞭解更多細節。</p>
<p><strong>Note</strong>: This is a fork of official rust rfcs. If you are interested in help translating, please have a look at <a href="CONTRIBUTING.html">CONTRIBUTING.md</a>.</p>
<p>Many changes, including bug fixes and documentation improvements can be
implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put through a
bit of a design process and produce a consensus among the Rust community and
the <a href="http://www.rust-lang.org/team.html">sub-team</a>s.</p>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a consistent
and controlled path for new features to enter the language and standard
libraries, so that all stakeholders can be confident about the direction the
language is evolving in.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="introduction.html#rust-rfcs">Opening</a></li>
<li><a href="introduction.html#table-of-contents">Table of Contents</a></li>
<li><a href="introduction.html#when-you-need-to-follow-this-process">When you need to follow this process</a></li>
<li><a href="introduction.html#before-creating-an-rfc">Before creating an RFC</a></li>
<li><a href="introduction.html#what-the-process-is">What the process is</a></li>
<li><a href="introduction.html#the-rfc-life-cycle">The RFC life-cycle</a></li>
<li><a href="introduction.html#reviewing-rfcs">Reviewing RFCs</a></li>
<li><a href="introduction.html#implementing-an-rfc">Implementing an RFC</a></li>
<li><a href="introduction.html#rfc-postponement">RFC Postponement</a></li>
<li><a href="introduction.html#help-this-is-all-too-informal">Help this is all too informal!</a></li>
<li><a href="introduction.html#license">License</a></li>
</ul>
<h2 id="when-you-need-to-follow-this-process"><a class="header" href="#when-you-need-to-follow-this-process">When you need to follow this process</a></h2>
<p>You need to follow this process if you intend to make &quot;substantial&quot; changes to
Rust, Cargo, Crates.io, or the RFC process itself. What constitutes a
&quot;substantial&quot; change is evolving based on community norms and varies depending
on what part of the ecosystem you are proposing to change, but may include the
following.</p>
<ul>
<li>Any semantic or syntactic change to the language that is not a bugfix.</li>
<li>Removing language features, including those that are feature-gated.</li>
<li>Changes to the interface between the compiler and libraries, including lang
items and intrinsics.</li>
<li>Additions to <code>std</code>.</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing, refactoring, or otherwise &quot;changing shape does
not change meaning&quot;.</li>
<li>Additions that strictly improve objective, numerical quality criteria
(warning removal, speedup, better platform coverage, more parallelism, trap
more errors, etc.)</li>
<li>Additions only likely to be <em>noticed by</em> other developers-of-rust,
invisible to users-of-rust.</li>
</ul>
<p>If you submit a pull request to implement a new feature without going through
the RFC process, it may be closed with a polite request to submit an RFC first.</p>
<h3 id="sub-team-specific-guidelines"><a class="header" href="#sub-team-specific-guidelines">Sub-team specific guidelines</a></h3>
<p>For more details on when an RFC is required for the following areas, please see
the Rust community's <a href="http://www.rust-lang.org/team.html">sub-team</a> specific guidelines for:</p>
<ul>
<li><a href="lang_changes.html">language changes</a>,</li>
<li><a href="libs_changes.html">library changes</a>,</li>
<li><a href="compiler_changes.html">compiler changes</a>.</li>
</ul>
<h2 id="before-creating-an-rfc"><a class="header" href="#before-creating-an-rfc">Before creating an RFC</a></h2>
<p>A hastily-proposed RFC can hurt its chances of acceptance. Low quality
proposals, proposals for previously-rejected features, or those that don't fit
into the near-term roadmap, may be quickly rejected, which can be demotivating
for the unprepared contributor. Laying some groundwork ahead of the RFC can
make the process smoother.</p>
<p>Although there is no single way to prepare for submitting an RFC, it is
generally a good idea to pursue feedback from other project developers
beforehand, to ascertain that the RFC may be desirable; having a consistent
impact on the project requires concerted effort toward consensus-building.</p>
<p>The most common preparations for writing and submitting an RFC include talking
the idea over on our <a href="https://discord.gg/rust-lang">official Discord server</a>, discussing the topic on our
<a href="http://internals.rust-lang.org/">developer discussion forum</a>, and occasionally posting &quot;pre-RFCs&quot; on the
developer forum. You may file issues on this repo for discussion, but these are
not actively looked at by the teams.</p>
<p>As a rule of thumb, receiving encouraging feedback from long-standing project
developers, and particularly members of the relevant <a href="http://www.rust-lang.org/team.html">sub-team</a> is a good
indication that the RFC is worth pursuing.</p>
<h2 id="what-the-process-is"><a class="header" href="#what-the-process-is">What the process is</a></h2>
<p>In short, to get a major feature added to Rust, one must first get the RFC
merged into the RFC repository as a markdown file. At that point the RFC is
&quot;active&quot; and may be implemented with the goal of eventual inclusion into Rust.</p>
<ul>
<li>Fork the RFC repo <a href="http://github.com/rust-lang/rfcs">RFC repository</a></li>
<li>Copy <code>0000-template.md</code> to <code>text/0000-my-feature.md</code> (where &quot;my-feature&quot; is
descriptive). Don't assign an RFC number yet; This is going to be the PR
number and we'll rename the file accordingly if the RFC is accepted.</li>
<li>Fill in the RFC. Put care into the details: RFCs that do not present
convincing motivation, demonstrate lack of understanding of the design's
impact, or are disingenuous about the drawbacks or alternatives tend to
be poorly-received.</li>
<li>Submit a pull request. As a pull request the RFC will receive design
feedback from the larger community, and the author should be prepared to
revise it in response.</li>
<li>Each pull request will be labeled with the most relevant <a href="http://www.rust-lang.org/team.html">sub-team</a>, which
will lead to its being triaged by that team in a future meeting and assigned
to a member of the subteam.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support are
much more likely to make progress than those that don't receive any
comments. Feel free to reach out to the RFC assignee in particular to get
help identifying stakeholders and obstacles.</li>
<li>The sub-team will discuss the RFC pull request, as much as possible in the
comment thread of the pull request itself. Offline discussion will be
summarized on the pull request comment thread.</li>
<li>RFCs rarely go through this process unchanged, especially as alternatives
and drawbacks are shown. You can make edits, big and small, to the RFC to
clarify or change the design, but make changes as new commits to the pull
request, and leave a comment on the pull request explaining your changes.
Specifically, do not squash or rebase commits after they are visible on the
pull request.</li>
<li>At some point, a member of the subteam will propose a &quot;motion for final
comment period&quot; (FCP), along with a <em>disposition</em> for the RFC (merge, close,
or postpone).
<ul>
<li>This step is taken when enough of the tradeoffs have been discussed that
the subteam is in a position to make a decision. That does not require
consensus amongst all participants in the RFC thread (which is usually
impossible). However, the argument supporting the disposition on the RFC
needs to have already been clearly articulated, and there should not be a
strong consensus <em>against</em> that position outside of the subteam. Subteam
members use their best judgment in taking this step, and the FCP itself
ensures there is ample time and notification for stakeholders to push back
if it is made prematurely.</li>
<li>For RFCs with lengthy discussion, the motion to FCP is usually preceded by
a <em>summary comment</em> trying to lay out the current state of the discussion
and major tradeoffs/points of disagreement.</li>
<li>Before actually entering FCP, <em>all</em> members of the subteam must sign off;
this is often the point at which many subteam members first review the RFC
in full depth.</li>
</ul>
</li>
<li>The FCP lasts ten calendar days, so that it is open for at least 5 business
days. It is also advertised widely,
e.g. in <a href="https://this-week-in-rust.org/">This Week in Rust</a>. This way all
stakeholders have a chance to lodge any final objections before a decision
is reached.</li>
<li>In most cases, the FCP period is quiet, and the RFC is either merged or
closed. However, sometimes substantial new arguments or ideas are raised,
the FCP is canceled, and the RFC goes back into development mode.</li>
</ul>
<h2 id="the-rfc-life-cycle"><a class="header" href="#the-rfc-life-cycle">The RFC life-cycle</a></h2>
<p>Once an RFC becomes &quot;active&quot; then authors may implement it and submit the
feature as a pull request to the Rust repo. Being &quot;active&quot; is not a rubber
stamp, and in particular still does not mean the feature will ultimately be
merged; it does mean that in principle all the major stakeholders have agreed
to the feature and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is &quot;active&quot;
implies nothing about what priority is assigned to its implementation, nor does
it imply anything about whether a Rust developer has been assigned the task of
implementing the feature. While it is not <em>necessary</em> that the author of the
RFC also write the implementation, it is by far the most effective way to see
an RFC through to completion: authors should not expect that other project
developers will take on responsibility for implementing their accepted feature.</p>
<p>Modifications to &quot;active&quot; RFCs can be done in follow-up pull requests. We
strive to write each RFC in a manner that it will reflect the final design of
the feature; but the nature of the process means that we cannot expect every
merged RFC to actually reflect what the end result will be at the time of the
next major release.</p>
<p>In general, once accepted, RFCs should not be substantially changed. Only very
minor changes should be submitted as amendments. More substantial changes
should be new RFCs, with a note added to the original RFC. Exactly what counts
as a &quot;very minor change&quot; is up to the sub-team to decide; check
<a href="introduction.html#sub-team-specific-guidelines">Sub-team specific guidelines</a> for more details.</p>
<h2 id="reviewing-rfcs"><a class="header" href="#reviewing-rfcs">Reviewing RFCs</a></h2>
<p>While the RFC pull request is up, the sub-team may schedule meetings with the
author and/or relevant stakeholders to discuss the issues in greater detail,
and in some cases the topic may be discussed at a sub-team meeting. In either
case a summary from the meeting will be posted back to the RFC pull request.</p>
<p>A sub-team makes final decisions about RFCs after the benefits and drawbacks
are well understood. These decisions can be made at any time, but the sub-team
will regularly issue decisions. When a decision is made, the RFC pull request
will either be merged or closed. In either case, if the reasoning is not clear
from the discussion in thread, the sub-team will add a comment describing the
rationale for the decision.</p>
<h2 id="implementing-an-rfc"><a class="header" href="#implementing-an-rfc">Implementing an RFC</a></h2>
<p>Some accepted RFCs represent vital features that need to be implemented right
away. Other accepted RFCs can represent features that can wait until some
arbitrary developer feels like doing the work. Every accepted RFC has an
associated issue tracking its implementation in the Rust repository; thus that
associated issue can be assigned a priority via the triage process that the
team uses for all issues in the Rust repository.</p>
<p>The author of an RFC is not obligated to implement it. Of course, the RFC
author (like any other developer) is welcome to post an implementation for
review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an &quot;active&quot; RFC, but
cannot determine if someone else is already working on it, feel free to ask
(e.g. by leaving a comment on the associated issue).</p>
<h2 id="rfc-postponement"><a class="header" href="#rfc-postponement">RFC Postponement</a></h2>
<p>Some RFC pull requests are tagged with the &quot;postponed&quot; label when they are
closed (as part of the rejection process). An RFC closed with &quot;postponed&quot; is
marked as such because we want neither to think about evaluating the proposal
nor about implementing the described feature until some time in the future, and
we believe that we can afford to wait until then to do so. Historically,
&quot;postponed&quot; was used to postpone features until after 1.0. Postponed pull
requests may be re-opened when the time is right. We don't have any formal
process for that, you should ask members of the relevant sub-team.</p>
<p>Usually an RFC pull request marked as &quot;postponed&quot; has already passed an
informal first round of evaluation, namely the round of &quot;do we think we would
ever possibly consider making this change, as outlined in the RFC pull request,
or some semi-obvious variation of it.&quot; (When the answer to the latter question
is &quot;no&quot;, then the appropriate response is to close the RFC, not postpone it.)</p>
<h3 id="help-this-is-all-too-informal"><a class="header" href="#help-this-is-all-too-informal">Help this is all too informal!</a></h3>
<p>The process is intended to be as lightweight as reasonable for the present
circumstances. As usual, we are trying to let the process be driven by
consensus and community norms, not impose more structure than necessary.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This repository is currently in the process of being licensed under either of:</p>
<ul>
<li>Apache License, Version 2.0, (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or http://www.apache.org/licenses/LICENSE-2.0)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or http://opensource.org/licenses/MIT)</li>
</ul>
<p>at your option. Some parts of the repository are already licensed according to those terms. For more see <a href="https://github.com/rust-lang/rfcs/pull/2044">RFC 2044</a> and its <a href="https://github.com/rust-lang/rust/issues/43461">tracking issue</a>.</p>
<h3 id="contributions"><a class="header" href="#contributions">Contributions</a></h3>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>const_generics</code></li>
<li>Start Date: 2017-05-01</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2000">rust-lang/rfcs#2000</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/44580">rust-lang/rust#44580</a></li>
<li>Translators: [<a href="https://github.com/yanganto">@yanganto</a>]</li>
<li>Commit: <a href="https://github.com/rust-tw/rfcs-tw/blob/725bf172f383a21cf74189feb5073705778d2206/text/2000-const-generics.md">The commit link this page based on</a></li>
<li>Updated: 2021-03-26</li>
</ul>
<h1 id="總結"><a class="header" href="#總結">總結</a></h1>
<p>允許所有型別（type）以作為常數值（constant values）的形式成為泛型（generic），這能讓使用者用 <code>impl</code> 寫出所有陣列型別（array types）。</p>
<h1 id="動機"><a class="header" href="#動機">動機</a></h1>
<p>現在的 Rust 有一種將常數參數化（parametric）型別︰內建的陣列型別 <code>[T; LEN]</code>。然而，常數泛型（const generics）並非第一級別的功能，使用者無法自己定義將常數值作爲泛型的型別，且不能對所有的陣列實作特徵（traits）。</p>
<p>在此限制下，標準庫僅包含長度最多到 32 的陣列實作，而陣列也因此被視爲語言的第二級別的功能。即使在長度可靜態已知的情形下，也大多調配於堆（heap）上成為向量（vector）而非使用陣列型別，因而造成一定程度上的效能取捨。</p>
<p>常數參數也能讓使用者更自然地指定一個泛型變體（variant）, 且相比於型別更能確切地反應其值。舉例來說，基於某些因素有個型別用一個名稱來作為參數的話，使用 <code>&amp;'static str</code> 來提供其名稱會比（藉由相關的常數或是函式提供的）單元型別（unit type）的形式還來的合理，這能簡化 API。</p>
<p>總結來說，常數可作爲參數使用，讓編譯器在型別檢查時期能確定這些數值。藉由限制哪些數值是否有實作過特定的特徵，孤兒規則（orphan rules）可以確保一個 crate 僅使用部份安全的數值。（例如有關密碼學的相關函式庫）</p>
<h1 id="設計細節"><a class="header" href="#設計細節">設計細節</a></h1>
<p>現今 Rust 中的型別有兩種參數化的形式︰型別與生命周期。如同在編譯時能推導出這些數值，我們將額外的允許型別將數值參數化。一個常數參數必為單一、特定型別，且可以有效的替換為編譯時期計算出的任意值且該型別將符合本 RFC 以下列出的要求。</p>
<p>（為明確在此 RFC 闡明哪些表達式可在編譯時評估，在之後的範例中，我們假設整數及其基本算數操作可以在編譯時計算。）</p>
<h2 id="詞彙表"><a class="header" href="#詞彙表">詞彙表</a></h2>
<ul>
<li>
<p><b>常數（constant, const value）︰</b>一個在編譯時期可以保證完全評估的 Rust 數值。不同於靜態數值（static），常數將在其使用的位置 inline 而非存在於編譯好的二進制檔案的資料區段。</p>
</li>
<li>
<p><b>常數參數、泛型常數（const parameter, generic const）︰</b>一個由型別或函式抽象而得到的常數。此常數是具體型別的輸入值，例如一個靜態陣列的長度。</p>
</li>
<li>
<p><b>關聯常數（associated const）︰</b>一個由特徵關聯而得到的常數，其相似於關聯型別。不同於常數參數，關聯常數是由型別所決定的。</p>
</li>
<li>
<p><b>常數變數（const variable）︰</b>相比於具體常數，常數參數或關聯常數皆為常數變數。在單態化（monomorphization）之前，一個常數在上下文中是未確定的。</p>
</li>
<li>
<p><b>具體常數（concrete const）︰</b>相比於常數變數，一個在上下文中已知且單一值的常數。</p>
</li>
<li>
<p><b>常數表達式（const expression）︰</b>一個用於評估一個常數的表達式。此可為一個身份表達式或一個在 Rust 常數系統中可以評估出的更複雜的表達式。</p>
</li>
<li>
<p><b>抽象常數表達式（abstract const expression）︰</b>一個包含常數變數的表達式。（因此在單態化結束前其值是無法評估的）</p>
</li>
<li>
<p><b>常數投影（const projection）︰</b>抽象常數表達式的數值（其在泛型上下文中因缺乏所依賴的常數變數而無法被定義）</p>
</li>
<li>
<p><b>身份表達式（identity expression）︰</b>一個在不以其範圍內的名稱進行置換則無法評估的表達式。此包括了所有的文字及身份（ident），例如，<code>3</code>、<code>&quot;Hello, world&quot;</code>、<code>foo_bar</code>。</p>
</li>
</ul>
<h2 id="宣告常數參數"><a class="header" href="#宣告常數參數">宣告常數參數</a></h2>
<p>在型別參數宣告的任何序列中都可以宣告常數參數（例如在一個型別的定義中或是在 <code>impl</code> 的標頭或區塊（block）中）。常數參數的格式爲 <code>const $ident: $ty</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RectangularArray&lt;T, const WIDTH: usize, const HEIGHT: usize&gt; {
    array: [[T; WIDTH]; HEIGHT],
}
<span class="boring">}
</span></code></pre></pre>
<p>這些宣告的身份（ident）就是常數參數（在本 RFC 內文中可替稱作「常數變數」）的名稱，而且所有數值必定其推導的型別。本 RFC 後文將說明能被推導的型別有哪些限制。</p>
<p>宣告的常數變數範圍在該項目（type、impl、function、method、…等等）的整體範圍中。</p>
<h2 id="套用常數作為參數"><a class="header" href="#套用常數作為參數">套用常數作為參數</a></h2>
<p>任何可推導出該常數參數型別的常數表達式都可作爲參數。除了陣列外，當套用一個表達式作為常數參數且該表達式並非身份表達式時，該表達式必須包含在區塊內 。此語法上的限制是必要的，以避免在型別中解析表達式需要無限地向前展望（lookahead）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: usize = 7;

let x: RectangularArray&lt;i32, 2, 4&gt;;
let y: RectangularArray&lt;i32, X, {2 * 2}&gt;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="陣列"><a class="header" href="#陣列">陣列</a></h3>
<p>陣列語法中有一個特別的構造語法：<code>[T; CONST]</code>。在陣列中大括號不需要存在於任何的常數表達式中，<code>[i32; N * 2]</code> 是一個合理的型別。</p>
<h2 id="何時可使用常數變數"><a class="header" href="#何時可使用常數變數">何時可使用常數變數</a></h2>
<p>常數變數可使用於下列上下文之任一項中︰</p>
<ol>
<li>用於任一型別中的常數，該型別是待定項目之簽章（signature）的一部份：<code>fn foo&lt;const N: usize&gt;(arr: [i32; N])</code></li>
<li>用於定義相關常數的常數表達式或相關型別之參數的一部份</li>
<li>在項目中任何函式的內部之任何運行時表達式中的數值</li>
<li>在項目中任何函式內部用於任何型別的參數，例如在 <code>let x: [i32; N]</code> 或 <code>&lt;[i32; N] as Foo&gt;::bar()</code>。</li>
<li>在項目中任何欄位之型別的一部分（如 <code>struct Foo&lt;const N: usize&gt;([i32; N]);</code>）</li>
</ol>
<p>在一般情況下，常數變數可以用做常數。但有一個明顯的例外是，常數變數不可用於常數、靜態型別、函式、或函式內的型別的建構子，意即下面的例子是不合規的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const X: usize&gt;() {
    const Y: usize = X * 2;
    static Z: (usize, usize)= (X, X);

    struct Foo([i32; X]);
}
<span class="boring">}
</span></code></pre></pre>
<p>這樣的限制就如同型別型別不能用在函式本體中建造的型別一樣。所有的宣告雖然專用於該項目，但也必需獨立於它，且不能有任何在其範圍內的參數。</p>
<h2 id="兩個常數的型別相等性之相等原則"><a class="header" href="#兩個常數的型別相等性之相等原則">兩個常數的型別相等性之相等原則</a></h2>
<p>在統一且重疊的檢查期間，何時兩個型別是否相等是關重要的。因為型別現在可依賴於常數了，所以我們必須定義我們如何比較兩個常數表達式的相等性。</p>
<p>在大多數情況下，兩個常數的相等性會如同你的預期，如果兩個常數彼此相等，則它們相等。但是仍會有一些特殊的狀況。</p>
<h3 id="結構相等性"><a class="header" href="#結構相等性">結構相等性</a></h3>
<p>常數相等性的定義是根據 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md">RFC 1445</a> 解釋的結構相等性所定義。只有在型別有「結構相符」的特性下，該結構才可用做常數參數。舉例來說，浮點數就會被排除在外。</p>
<p>在最終解決方案出來前，結構相符這樣的性質應作為權宜之計。無論變數參數採用什麼解決方案，確保相等是具有反射性（reflexive）對於型別相等而言是重要的，這樣才能使得型別始終相同。（浮點數相等的標准定義是不具反射性）</p>
<p>這可能會與未來進行配對（match）的定義而有所不同，但是配對和常數參數不一定得使用相同的相等性定義，現今所使用的相等性定義已經足以滿足我們的目的。</p>
<p>因為常數必須具有結構相符的性質，並且此性質無法強制轉成一個型別變數，因此我們無法定義一個常數參數是從其他型別變數推導來的。（意即 <code>Foo &lt;T，const N：T&gt;</code>不是合規的）</p>
<h3 id="兩個抽像表達式的相等性"><a class="header" href="#兩個抽像表達式的相等性">兩個抽像表達式的相等性</a></h3>
<p>在比較兩個抽象常數表達式（即依賴於變數的表達式）的相等性時，我們無法比較其值的相等性，因其值是由常數變數所決定的，而在在單態化之前是未知的。</p>
<p>基於這個原因，我們至少會將常數表達式的返回值當作投影（projections）。雖然其值仍保持未知，我們仍藉由輸入值來決定其值，這是作法相同於現在我們處理關聯型別（associated types）的作法。此作法我們將稱為常數投影（const projection），對另一個同型別的常數而言，我們永遠無法確定其相等性。</p>
<p>每個常數表達式都會生成一個新的投影，該投影本質上是匿名的。不可能使兩個匿名投影一致（想像兩個關聯型別的泛型 <code>T :: Assoc</code> 和 <code>T :: Item</code>，你無法證明或否定它們是否為同一型別）。因此，除非它們從字面上使用完完全全相同的文字，否則常數表達式在 AST 節點中是彼此不一樣的。這意味著 <code>N + 1</code> 的一個實例不會與另一個 <code>N + 1</code> 的實例在型別相同。</p>
<p>更清楚來說，以下是無法通過型別檢查的，因為 <code>N + 1</code> 會是兩種不同的型別：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const N: usize&gt;() -&gt; [i32; N + 1] {
    let x: [i32; N + 1] = [0; N + 1];
    x
}
<span class="boring">}
</span></code></pre></pre>
<p>但如果這樣寫的話，它將只有一個型別：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;const N: usize&gt; = [i32; N + 1];

fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; {
    let x: Foo&lt;N&gt; = Default::default();
    x
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="未來的擴展性"><a class="header" href="#未來的擴展性">未來的擴展性</a></h4>
<p>未來的某一天我們可以利用一些操作的基本性質（例如加法和乘法的可交換性），而對常數投影的相等性做出更聰明的判斷。但是，本 RFC 並不打算在此提案中建造這些可能性，而是打算留給未來的 RFC 決定。</p>
<h2 id="常數變數的特化specialization"><a class="header" href="#常數變數的特化specialization">常數變數的特化（Specialization）</a></h2>
<p>定義常數參數特化的順序也是很重要的。為此，將字面上的定義必需比其他表達式更具體，否則表達式定義的順序上也會產生不確定性。</p>
<p>正如我們有朝一日可以在常數投影上支援更進階的相等性一樣，我們可以支援更進階的特化定義。例如，給定型別為 <code>(i32, i32)</code>，我們可以確定 <code>(0, PARAM2)</code> 比 <code>(PARAM1, PARAM2)</code> 更為具體；<code>(i32, U)</code> 比 <code>(T, U)</code> 更為具體。在未來的某天我們將也有可能在常數特化上支援多元交互（intersectional）和其他更進階的定義。</p>
<h1 id="我們如何教導這個"><a class="header" href="#我們如何教導這個">我們如何教導這個</a></h1>
<p>常數泛型是一個很龐大的功能，將需要大量的教育資源，這將會需要寫在在書本跟參考文件中，且可能會在書中有獨立的章節。常數泛型的文件化過程本質上將會是一個大工程。</p>
<p>然而，常數泛型應該被視為進階功能，並且在使用 Rust 的初期，我們應該不會向新手介紹這些內容。</p>
<h1 id="缺點"><a class="header" href="#缺點">缺點</a></h1>
<p>此功能由於允許型別由常數決定，將為型別系統增加了大量的複雜性。它需要抽象變數相等性的確定規則，這出現了很多令人意外的的特殊情況。它增加了 Rust 的很多語法。如果我們不要採用此功能，Rust 肯定會更簡單。</p>
<p>然而，我們已經引入了一種由常數確定的型別（數組型別）。泛型化的功能似乎是必然的，甚至是不可避免的，鑑於此，我們應該盡早決定。</p>
<h1 id="替代方案"><a class="header" href="#替代方案">替代方案</a></h1>
<p>除了暫緩執行或不執行外，並沒有真的替代方案。</p>
<p>我們可以限制常數泛型為 <code>usize</code> 型別，但這不會讓實作更為簡單。</p>
<p>我們可以對常數相對性的複雜概念更積極地發展，但這會使實作比上述說明得更加複雜。</p>
<p>我們可以選擇稍微不同的語法，例如將在常數跟型別間加上分號。</p>
<h1 id="未解決問題"><a class="header" href="#未解決問題">未解決問題</a></h1>
<ul>
<li><b>一致的抽象常數表達式︰</b>本 RFC 盡可能最大限度地減少抽象常數表達式的統合性上的處理，從本質上來說，並沒有使其一致。這可能造成無法接受的使用者體驗的不穩定，而我們想要實作一些更進些的統合性之前穩定此功能。</li>
<li><b>常數表達式之正確格式︰</b>只有在單態化過程中，程式不會恐慌（panic）的情況下，此型別才能視爲正確格式。這對於溢出和超出範圍的陣列存取來說很棘手。然而，我們實際上只能確保在函式的簽章中表達式常數的格式進行正確性約束。目前尚不清楚有關在函式中抽象常數表達式之格式正確性的處理方式，也因此使實作推遲。</li>
<li><b>排序與預設參數︰</b>所有常數參數是否將排在最後，或者將它們與型別混合嗎？具有預設值的參數是否須在沒有預設值之後？這些決定推遲到實作語法的討論中。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>const-control-flow</code></li>
<li>Start Date: 2018-01-11</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2342">rust-lang/rfcs#2342</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/49146">rust-lang/rust#49146</a></li>
<li>Translators: [<a href="https://github.com/CYBAI">@CYBAI</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/dfe697106478a52bddc000477e8cd0621bcc1a20/text/2342-const-control-flow.md">The commit link this page based on</a></li>
<li>Updated: 2020-09-05</li>
</ul>
<h1 id="總結-1"><a class="header" href="#總結-1">總結</a></h1>
<p>透過此功能，可以在常數求值（const evaluation）中使用 <code>if</code> 及 <code>match</code> 並使他們被延遲求值。簡單來說，這項功能允許我們寫 <code>if x &lt; y { y - x } else { x - y }</code>；即使當使用非負型別時在 <code>x &lt; y</code> 的 <code>else</code> 分支會報溢位錯誤 (overflow error)。</p>
<h1 id="動機-1"><a class="header" href="#動機-1">動機</a></h1>
<p>在常數宣告中使用條件式對於建立像是 <code>NonZero::new</code> 的 <code>const fn</code> 及 直譯判定（interpreting assertions）來說很重要。</p>
<h1 id="教學式解說"><a class="header" href="#教學式解說">教學式解說</a></h1>
<p>如果你寫</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = ...;
let y: u32 = ...;
let a = x - y;
let b = y - x;
if x &gt; y {
    // do something with a
} else {
    // do something with b
}
<span class="boring">}
</span></code></pre></pre>
<p>這支程式永遠都會 panic（除非 <code>x</code> 和 <code>y</code> 同時是 <code>0</code>）因為不管是 <code>x - y</code> 或是 <code>y - x</code> 都會造成溢位。為了解決此問題，我們必須把 <code>let a</code> 及 <code>let b</code> 個別搬進 <code>if</code> 及 <code>else</code> 中。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = ...;
let y: u32 = ...;
if x &gt; y {
    let a = x - y;
    // do something with a
} else {
    let b = y - x;
    // do something with b
}
<span class="boring">}
</span></code></pre></pre>
<p>當改用常數時，上面的寫法就會出現新問題：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const FOO: SomeType = if X &gt; Y {
    const A: u32 = X - Y;
    ...
} else {
    const B: u32 = Y - X;
    ...
};
<span class="boring">}
</span></code></pre></pre>
<p><code>A</code> 和 <code>B</code> 會比 <code>FOO</code> 先被求值，因為常數在定義上就是「常數」，所以不應被求值順序影響。這項假設在有錯誤的情況下並不成立，因為錯誤屬於副作用（side effects），因此不純（pure）。</p>
<p>為了解決此問題，我們必須把中介常數消掉並改為直接對 <code>X - Y</code> 及 <code>Y - X</code> 求值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const FOO: SomeType = if X &gt; Y {
    let a = X - Y;
    ...
} else {
    let b = Y - X;
    ...
};
<span class="boring">}
</span></code></pre></pre>
<h1 id="技術文件式解說"><a class="header" href="#技術文件式解說">技術文件式解說</a></h1>
<p><code>if</code> 或是在 variant 沒有欄位的 enums 上做 <code>match</code> 會在 HIR -&gt; MIR 階段時，被轉譯成 <code>switchInt</code> 終止器（terminator）。Mir 直譯器現在將會針對那些終止器求值（之前就可以了）。</p>
<p>在 variant 沒有欄位的 enums 上做 <code>match</code> 會被轉譯成 <code>switch</code>，表示他會被檢查 discriminant 或是在 packed enums（例如 <code>Option&lt;&amp;T&gt;</code>）的情況會運算 discriminant（這個情況 discriminant 沒有特別的記憶體位址，但他會把所有的零視為 <code>None</code>，並把其他的值都當作 <code>Some</code>）。當進入 <code>match</code> 的分支時，匹配上的值基本上會被 transmute 成 enum 的 variant 型別，如此一來可以允許其他程式碼來存取該 enum 的欄位。</p>
<h1 id="缺點-1"><a class="header" href="#缺點-1">缺點</a></h1>
<p>這項功能容易造成任意「常數」值（如：<code>size_of::&lt;T&gt;()</code> 或是特定的平台常數）編譯失敗。</p>
<h1 id="原理及替代方案"><a class="header" href="#原理及替代方案">原理及替代方案</a></h1>
<h2 id="利用中介-const-fns-來破壞立即常數求值eager-const-evaluation"><a class="header" href="#利用中介-const-fns-來破壞立即常數求值eager-const-evaluation">利用中介 const fns 來破壞立即常數求值（eager const evaluation）</a></h2>
<p>如果寫成</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const AB: u32 = if X &gt; Y {
    X - Y
} else {
    Y - X
};
<span class="boring">}
</span></code></pre></pre>
<p><code>X - Y</code> 或是 <code>Y - X</code> 其中一方有可能會報錯，這時必須加入中介 const fn</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const X: u32 = ...;
const Y: u32 = ...;
const fn foo(x: u32, y: u32) -&gt; u32 {
    if x &gt; y {
        x - y
    } else {
        y - x
    }
}
const AB: u32 = foo(X, Y);
<span class="boring">}
</span></code></pre></pre>
<p>const fn 的 <code>x</code> 和 <code>y</code> 參數未知，無法做常數求值（const evaluate）。當提供此 const fn 參數並求值時，只會對相應的分支求值。</p>
<h1 id="未解決問題-1"><a class="header" href="#未解決問題-1">未解決問題</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>min_rust_version</code></li>
<li>Start Date: 2018-06-28</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/2495">rust-lang/rfcs#2495</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/65262">rust-lang/rust#65262</a></li>
<li>Translators: [<a href="https://github.com/weihanglo">@weihanglo</a>]</li>
<li>Commit: <a href="https://github.com/rust-lang/rfcs/blob/3071138d4ed510d6dfc1f8e1d7e9d4b099ea12e8/text/2495-min-rust-version.md">The commit link this page based on</a></li>
<li>Updated: 2020-09-07</li>
</ul>
<h1 id="總結-2"><a class="header" href="#總結-2">總結</a></h1>
<p>在 <code>Cargo.toml</code> 的 package 區塊加入 <code>rust</code> 欄位，用於指定 crate 的最低支援 Rust 版本（Minimum Supported Rust Version，MSRV）。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
rust = &quot;1.30&quot;
</code></pre>
<h1 id="動機-2"><a class="header" href="#動機-2">動機</a></h1>
<p>當前 crate 無任何正式方法指定 MSRV，導致使用者無法在不建構該 crate 的情況下得知 crate 是否可透過他們的工具鏈（toolchain）建構。這也帶來有關如何在提升 MSRV 時管理 crate 版本的爭論，保守的作法是將之視為破壞性改動，這種作法會阻礙整個生態採納新功能，或使得版本號通膨式提升，進而讓下游的 crate 很難跟上。另一方面，若作法稍微寬鬆些，則導致採用較舊編譯器版本的使用者無法成功編譯它們的 crate。</p>
<h1 id="教學式解說-1"><a class="header" href="#教學式解說-1">教學式解說</a></h1>
<p>若你想指定一個特定 MSRV 版本，請在 <code>Cargo.toml</code> 的 <code>[package]</code> 區塊中的 <code>rust</code> 欄位設定指定的 Rust 版本。如果你建構一個 crate 時有任一依賴要求的 MSRV 比你當前工具鏈更高，會導致編譯錯誤，指明該依賴與它的 MSRV。這個行為可以透過 <code>--no-msrv-check</code> 選項來停用。</p>
<h1 id="技術文件式解說-1"><a class="header" href="#技術文件式解說-1">技術文件式解說</a></h1>
<p>在建構過程（包含 <code>run</code>、<code>test</code>、<code>benchmark</code>、<code>verify</code> 與 <code>publish</code> 子指令），<code>cargo</code> 會以依賴樹（dependency tree）的形式，檢查所有將要建構或檢查的所有 crate 之 MSRV 要求。在依賴樹內但不會被構建的 crate 不會執行此項檢查（例如特定目標平台或可選的 crate）。</p>
<p><code>rust</code> 欄位應至少遵循下列要求：</p>
<ul>
<li>其值需遵守語意化版號且不能有範圍運算子。注意，「1.50」是合法的值，代表「1.50.0」。</li>
<li>版本不能比當前 stable 工具鏈高（上傳 crate 時 crates.io 會檢查）。</li>
<li>版本不能低於 1.27（此版本將 <code>package.rust</code> 欄位從錯誤改為警告）。</li>
<li>版本不能比選用的 edition 釋出的版本低，舉例來說，同時出現 <code>rust = &quot;1.27&quot;</code> 與 <code>edition = 2018</code> 是非法的。</li>
</ul>
<h1 id="未來展望與延伸"><a class="header" href="#未來展望與延伸">未來展望與延伸</a></h1>
<h2 id="對版本解析之影響"><a class="header" href="#對版本解析之影響">對版本解析之影響</a></h2>
<p><code>rust</code> 欄位之值（手動設定或 <code>cargo</code> 自動選擇）會用於選擇合適的依賴版本。</p>
<p>舉例來說，想像你的 crate 相依 crate <code>foo</code>，一個發佈了從 <code>0.1.0</code> 到 <code>0.1.9</code> 十個版本的 crate，其中 <code>0.1.0</code> 到 <code>0.1.5</code> 版在 crates.io 上 <code>Cargo.toml</code> 的 <code>rust</code> 欄位為「1.30」，其他版本則為「1.40」。現在，你建構一個專案用了例如 Rust 1.33 版，<code>cargo</code> 會選用 <code>foo v0.1.5</code>。<code>foo v0.1.9</code> 只會在你用 Rust 1.40 或更高版本建構專案時選用。倘若你嘗試使用 Rust 1.29 建構專案，cargo 會回報錯誤。</p>
<p><code>rust</code> 欄位值也會被檢核。在 crate 建構過程，<code>cargo</code> 將檢查所有上游相依是否可以在指定 MSRV 下建構。（例如，檢查給定的 crate 與 Rust 版本限制條件下是否存在解）已除去（yank）的 crate 會略過這個檢查步驟。</p>
<p>期望實作這項功能得以替長久以來對 MSRV 提升是否為破壞性改動的爭論劃下休止符，並讓 crate 作者提升 crate 的 MSRV 不再如此綁手綁腳。（儘管對於已 1.0 的 crate 來說，透過提升修訂號（patch version）來提升 MSRV 次版號，以接納修復嚴重問題的 backport，可能是個有用的慣例）</p>
<p>注意，上述 MSRV 限制與依賴版本解析檢查，可以透過 <code>--no-msrv-check</code> 選項停用。</p>
<h2 id="發佈時檢查-msrv"><a class="header" href="#發佈時檢查-msrv">發佈時檢查 MSRV</a></h2>
<p><code>cargo publish</code> 將檢查上傳是以 <code>rust</code> 欄位指定的工具鏈版本完成，若工具鏈版本有異，<code>cargo</code> 會拒絕上傳該 crate。此確保機制避免因為未預期的 MSRV 提升導致錯誤的 <code>rust</code> 欄位值。這項檢查可透過既有的 <code>--no-verify</code> 選項停用。</p>
<h2 id="將-rust-欄位設為必填"><a class="header" href="#將-rust-欄位設為必填">將 <code>rust</code> 欄位設為必填</a></h2>
<p>未來（可能是下一個 edition），我們可以設定新上傳的 crate 的 <code>rust</code> 欄位為必填。既有 crate 的 MSRV 會透過 <code>edition</code> 決定。換句話說 <code>edition = 2018</code> 之 MSRV 必然是 <code>rust = &quot;1.31&quot;</code>，而 <code>edition = &quot;2015&quot;</code> 則是 <code>rust = &quot;1.0&quot;</code>。</p>
<p><code>cargo init</code> 將會使用當前工具鏈使用的版本。</p>
<h2 id="基於-cfg-的-msrv"><a class="header" href="#基於-cfg-的-msrv">基於 <code>cfg</code> 的 MSRV</a></h2>
<p>部分 crate 會根據不同目標架構平台或啟用的功能而有不同的 MSRV。可透過以下方式有效指定 MSRV 如何依賴這些配置：</p>
<pre><code class="language-toml">[package]
rust = &quot;1.30&quot;

[target.x86_64-pc-windows-gnu.package]
rust = &quot;1.35&quot;

[target.'cfg(feature = &quot;foo&quot;)'.package]
rust = &quot;1.33&quot;
</code></pre>
<p>在 <code>target</code> 區塊中所有 <code>rust</code> 值應等於或高於在 <code>package</code> 區塊的 <code>rust</code> 值。</p>
<p>若 <code>target</code> 的條件為真，<code>cargo</code> 會取用該區塊的 <code>rust</code> 值。若多個 target 區塊的條件為真，則取用最大值。</p>
<h2 id="nightly-與-stable-版本"><a class="header" href="#nightly-與-stable-版本">Nightly 與 stable 版本</a></h2>
<p>部分 crate 可能偏好在最新 stable 或 nighly 工具鏈，除了指定版本之外，我們可允許宣告 <code>stable</code> 或 <code>nightly</code> 值，讓維護者不需追蹤該 crate 的 MSRV 。</p>
<p>對於某些超前沿的 crate（例如： <code>rocket</code>）常常因為 Nightly 更新就壞，將可指定特定可成功建構的 Nightly 版本。透過下列語法來達成：</p>
<ul>
<li>自動選擇：<code>nightly</code> 此寫法與寫 <code>stable</code> 的行為一致，將使用等於當前或更高的 nightly 版本。</li>
<li>單一版本：<code>nightly: 2018-01-01</code> （主要寫法）</li>
<li>列舉：<code>nightly: 2018-01-01, 2018-01-15</code></li>
<li>類語意化版本條件：<code>nightly: &gt;=2018-01-01</code>、<code>nightly: &gt;=2018-01-01, &lt;=2018-01-15</code>、<code>nightly: &gt;=2018-01-01, &lt;=2018-01-15, 2018-01-20</code>。（後者會解讀為 「(version &gt;= 2018-01-01 &amp;&amp; version &lt;= 2018-01-20) || version == 2018-01-20」）</li>
</ul>
<p>這些條件或許很嚴苛，盼使用這功能的 crate 一隻手數得出來。</p>
<h1 id="缺點-2"><a class="header" href="#缺點-2">缺點</a></h1>
<ul>
<li>即使宣告了 MSRV 且檢查過，並無法保持 crate 能夠正確在指定 MSRV 下正確執行，只有合理配置的 CI 能做到此事。</li>
<li>更複雜的依賴版本解析演算法。</li>
<li>使用 <code>cargo publish</code> 配合 MSRV <code>rust = &quot;stable&quot;</code> 恐過於保守。</li>
</ul>
<h1 id="替代方案-1"><a class="header" href="#替代方案-1">替代方案</a></h1>
<ul>
<li>自動計算 MSRV。</li>
<li>不做任何事，依靠 <a href="https://github.com/rust-lang/rfcs/pull/2483">LTS 發行</a> 的 crate MSRV 提升。</li>
<li>允許在 <a href="https://github.com/rust-lang/rfcs/pull/2523">RFC 2523</a> 中提出基於版本與路徑的 <code>cfg</code> 屬性（attribute）</li>
</ul>
<h1 id="先驅技術"><a class="header" href="#先驅技術">先驅技術</a></h1>
<p>早先的提案：</p>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/1707">RFC 1707</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/1709">RFC 1709</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/1953">RFC 1953</a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2182">RFC 2182</a>（這個非常有爭議的離題了）</li>
</ul>
<h1 id="未解決問題-2"><a class="header" href="#未解決問題-2">未解決問題</a></h1>
<ul>
<li>瑣碎的命名問題：<code>rust</code> 或 <code>rustc</code> 還是 <code>min-rust-version</code></li>
<li>額外的檢查？</li>
<li>更優質地說明版本解析演算法</li>
<li>nightly 版本如何與「基於 cfg 的 MSRV」運作？</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
